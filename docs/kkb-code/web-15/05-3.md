### 主题

- 利用defineProperty实现数据劫持
- 利用ES6中proxy实现数据劫持
- 实现数据驱动视图更新，实现数据响应
- 发布订阅模式
- AMD模块化require.js介绍

### 知识点

- defineProperty
- Proxy代理
- 数据劫持
- 发布订阅
- 观察者模式与发布订阅
- 数据响应式

## 1、defineProperty

- 对象创建方式：

1、字面量 ；2、构造函数； 3、Object.create() ；4、Object.defineProoerty() ；5、通过类实例化对象

- 1、字面
```js
let obj = {
  name: '张三',
  age: 20
}
console.log(obj)
```

- 2、构造函数
```js
// new作用：执行函数；创建空对象；将空对象和this绑定；如果没有返还值，隐式返回this
function Person(name) {
  this.name = name
}
let zhangsan = new Person('张三')
console.log(zhangsan)
```

- 3、Object.create()
```js
// 创建一个公共域，属性和方法挂载在原型上
let obj = Object.create({
  name: '张三',
  age: 20
})
console.log(obj)
```

- ### 4、Object.defineProperty()
```js
// 属性可监听
// 默认不能删除: configurable默认为false
// 不可遍历：enumerable默认为false
let obj = Object.defineProperty({}, 'name', {
  configurable: true, // 手动设置true后可删除
  enumerable: true, // 手动设置true后可遍历
  get() {
    cosnole.log('get')
  },
  set(newValue) {
    console.log('set')
  }
})
console.log(obj)
// delete obj.name
for(let key in obj) {
  console.log(key)
}
```

### 实现数据观察、数据劫持
```js
let data = {
  name: '张三',
  age: 20
}
function Observer(data) {
  Object.keys(data).forEach(key => {
    let value = data[key]
    Object.defineProperty(data, key, {
      configurable: true,
      enumerable: true,
      get() {
        console.log('get')
        return value
      },
      set(newValue) {
        console.log('set')
        value = newValue
      }
    })
  })
}
Observer(data)
console.log(data)
```

## 2、Proxy

- 定义：

## 3、数据劫持

## 4、发布订阅监听数据的更新

- v-model数据响应式

## 5、观察者模式

定义一个对象与其他对象之间的一种依赖关系，当对象发生某种变化的时候，依赖它的其他对象会得到更新，一对多的关系。

## 6、发布订阅模式

**发布-订阅**是一种[消息](https://zh.wikipedia.org/wiki/消息)[范式](https://zh.wikipedia.org/wiki/范式)，消息的发送者（称为发布者）不会将消息直接发送给特定的接受者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或者多个类别的兴趣，只接受敢兴趣的消息，无需了解那些发布者的存在。

## &、二者的关系

观察者模式观察者与订阅者之间有直接联系。发布订阅中发布者和订阅者无直接依赖关系。观察者模式属于紧解耦，发布订阅模式属于松解耦。发布订阅广义上是观察者模式。

## 7、AMD require.js

## 8、模块化优点

- 防止作用域污染
- 提高代码复用性
- 降低维护成本

