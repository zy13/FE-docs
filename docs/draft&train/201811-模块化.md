### 模块化
>amd cmd umd namespace

```js
AMD: asynchronous module definition, 异步模块定义
CMD: common module definition, 公用模块定义
UMD: universal module definition, 通用模块定义
```

* [RequireJS和AMD](http://javascript.ruanyifeng.com/tool/requirejs.html) 
>AMD主要是客户端JS的表现制定的规范

>下面是没有requirejs的amd
```js
// 语法
// id: 模块标识，可以省略
// dependencies|modules(array): 所依赖的模块，可以省略
// factory(object|function): 模块的实现，或者一个JavaScript对象, 不可以省略
define(id?,dependencies? | modules?,factory)

// 1️⃣只有factory-object
define({
  m1: function(){},
  m2: function(){}
})
// 2️⃣：与1️⃣等价-function
define(function(){
  return {
    m1: function(){},
    m2: function(){}
  }
})
// 两个参数：第一个参数是moduel|dependencies(array)，第二个参数是function
define(['module1','module2'], function(m1, m2){
  return{
    m1: m1.getMethods(),
    m2: m2.getMethods()
  }
})
```

>下面是有require的amd, 可以实现动态加载模块
```js
// 使用requireJs实现动态加载
define(function(require){
  var isReady = false, foobar
  require(['foo','bar'], function(foo, bar){
    isReady = true
    foobar = foo() + bar()
  })
  return {
    isReady: isReady,
    foobar: foobar
  }
})
```
>define和require这两个模块定义模块、调用模块的方法，合称为AMD模式
>模块定义方式清晰，不会污染全局环境，能够清楚地显示依赖
>AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需求动态加载模块

* CommondJS
>CommonJS是为服务端的JS表现而制定的规范
```js
CommondJS定义的模块
1、模块引用(require)
2、模块定义(exports), 用于导出当前模块的方法或者变量
3、模块标识(module), module对象本身
```
>CommonJS主要是为了服务端的表现制定，不适合客户端？

```js
服务端做了哪些事情：
  1 同样的代码需要执行多次
  2 cpu和内存资源是瓶颈
  3 加载时从磁盘加载
客户端做了哪些事情：
  1 代码需要从一个服务端分发到多个客户端
  2 宽带时瓶颈
  3 加载时需要通过网络加载
```

* CMD
>cmd与seajs统称cmd规范, 与requirejs和amd统称的amd规范特别像

```js
define(function(require, exports, module){...})
```

* seajs与requirejs的异同
```js
相同之处
seajs和requirejs是模块加载器，进行模块化管理，核心价值是将js模块化开发变得简单

不同之处
定位不同：requirejs同时是浏览器和node的模块加载器，seajs只是浏览器的模块加载器
遵循的规范不一样：requirejs遵循AMD规范，seajs遵循CMD规范；
模块加载顺序不一样：seajs是懒加载，也即动态加载；requirejs是预加载
```

* UMD
>Universal Module Definition, 通用模块定义，即兼容了AMD和CommonJS。
>此规范的js文件,是立即执行函数。函数有两个参数，第一个是执行的环境，第二个是模块的定义体

```js
(function(window, factory){
  if (typeof exports === 'objext){
    module.exports = factory()
  } else if (typeof define === 'function' && define.amd) {
    define(factory())
  } else {
    window.eventUtil = factory()
  }
}(this, function($){
  // module...
}))
```
>在执行UMD规范的js文件时，会优先判断是否存在exports，存在则引用node模块，然后才会判断是否支持AMD的define



