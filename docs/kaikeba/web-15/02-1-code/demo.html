<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
</body>

<script>
// js里的对象
// let obj = {
//   name: '张三',
//   age: 22,
//   hobby: function () {
//     console.log('喜欢篮球')
//   }
// }
// let obj = new Object({
//   name: '张三',
//   age: 22,
//   hobby: function () {
//     console.log('喜欢篮球')
//   }
// })
// 放在原型对象
// let obj = Object.create({ 
//   name: '张三',
//   age: 22,
//   hobby: function () {
//     console.log('喜欢篮球')
//   }
// })

// 对象和类
// let zhangsan = {
//   name: '张三',
//   age: 22,
//   hobby: function() {
//     console.log('打篮球')
//   }
// }
// let lisi = {
//   name: '李四',
//   age: 24,
//   hobby: function() {
//     console.log('打篮球')
//   }
// }
// 类
// function Person(name, age) {
//   let obj = {}
//   obj.name = name
//   obj.age = age
//   obj.hobby = function() {
//     console.log('打篮球')
//   }
//   return obj
// }
// let zhangsan = Person('张三', 22)
// let lisi = Person('李四', 24)
// console.log(zhangsan, lisi)

// 工厂模式
// function Person(name, age) {
//   let obj = {} // 原料
//   obj.name = name 
//   obj.age = age
//   obj.hobby = function() {
//     console.log('喜欢打篮球')
//   }
//   // 原料加工
//   return obj // 出厂
// }

// new运算符：1.运行函数 2.创建一个空对象并绑定this，使this指向空对象  3.隐式返回this
// function test() {
//   console.log('test')
// }
// test();
// new test();
// function Person(name, age) {
//   this.name = name 
//   this.age = age
//   this.hobby = function() {
//     console.log('喜欢打篮球')
//   }
// }
// let zhangsan = new Person('张三', 22)
// console.log(zhangsan)

// 构造函数&静态成员：1.首字母大写 2.this指向实例化对象
// function Person(name, age) {
//   this.num = 0
//   this.name = name
//   this.age = age
//   this.hobby = function() {
//     console.log('喜欢篮球')
//   }
// }
// Person.num = 0
// let zhangsan = new Person('张三',22)
// Person.num++
// zhangsan.num++
// let lisi = new Person('李四', 24)
// Person.num++
// lisi.num++
// console.log(Person.num)
// 静态属性方法属于类本身

// 原型：公共空间
// function Person(name, age) {
//   this.name = name
//   this.age = age
// }
// Person.prototype.hobby = function() {
//   console.log('喜欢篮球')
// }
// Person.prototype.fn = function() {
//   console.log('fn')
// }
// let zhangsan = new Person('张三',22)
// let lisi = new Person('李四', 24)
// console.log(zhangsan.__proto__.hobby===Person.prototype.hobby)

// 原型的固有属性
// console.log(Person.prototype.constructor===Person)
// console.log(zhangsan.constructor)

// constructor可用于判断实例对象的类型
// let str = 'abc'
// console.log(str.constructor===String)

// 对象、构造函数、原型 三者之间的关系
// 1. 构造函数：通过new命令，实例化一个对象；通过prototype得到原型；构造函数的this指向实例化对象
// 2. 原型：通过constructor指向构造函数；原型的this指向实例化的对象
// let temp
// function Person(name) {
//   this.name = name
//   this.age = 20
// }
// Person.prototype.fn = function() {
//   console.log('fn')
//   temp = this
// }
// console.log(temp)
// console.log(Person.prototype.constructor === Person)
// let zhangsan = new Person('张三')
// zhangsan.fn()
// console.log(zhangsan.constructor===Person)

// 工厂模式对比构造模式：
// 1.工厂模式没有原型，无法创建公共空间，比较消耗性能；
// 2.工厂模式没有构造器constructor对象，无法判断对象的类型

// 原型链
// 原型对象：自身的属性和原型
// 构造函数
// function Foo(name) {
//   this.name = name
//   this.age = 20
//   // this.test = '你好11'
// }
// // 原型对象
// Foo.prototype.fn = function() {
//   console.log('f1')
// }
// // Foo.prototype.test = 'hello'
// // Object.prototype.test = '嗨'
// let newFoo = new Foo('张三')
// let obj = new Object()
// console.log(Object.prototype.__proto__)
// // console.log(newFoo.test)

//实现构造函数继承的三种方法：call apply bind 改变构造函数的this指向
// call与apply主要是传参的区别
// bind第一次执行会返回新的函数，在返回函数基础上再执行一次才会生效
// function foo(name, age) {
//   console.log(this)
//   console.log(`姓名是${name},年龄是${age}`)
// }
// let obj ={
//   name: '李四',
//   age: 24
// }
// foo('张三', 20) // this指向window
// foo.call(obj, '张三1', 20)
// foo.apply(obj, ['张三2', 20])
// foo.bind(obj)('张三3', 20)

// 构造函数的继承: 提高代码复用性 精简代码 提高可维护性
// call apply bind 无法继承原型的继承
// function Dad(name, age) {
//   this.name = name
//   this.age = age
//   this.money = '100000'
// }
// function Son(name, age) {
//   // Dad.call(this, name, age)
//   // Dad.apply(this, [name, age])
//   Dad.bind(this)(name, age)
//   this.sex = '男'
// }
// let son = new Son('张三', 20)
// console.log(son.money)
// console.log(son.sex)

// 原型的继承：
// Dad.prototype.fn = function() {
//   console.log('fn')
// }
// Son.prototype = Dad.prototype
// Son.prototype.fn = function() {
//   console.log('重写的fn')
// }
// let zhangsan = new Son('张三', 20)
// zhangsan.fn()
// let lisi = new Dad('李四', 50)
// lisi.fn()

// 传值和传址：
// 复杂数据类型-传址：互相引用，相互之间会受影响；
// 基本数据类型-传值，每声明一个变量都会开辟新的地址；相互之间不会影响，
// 复杂类型-传址：如Object、Array、Date、Math、RegExp等
// let DadProto = {
//   name: '张三',
//   age: 22
// }
// let SonProto = DadProto
// SonProto.name = '李四'
// console.log(DadProto.name === SonProto.name)
// 基本数据类型-传值：Number, Null, Undefined, String，Boolean等
// let a = 5
// let b = a
// b=6
// console.log(b)
// console.log(a)

// 原型的深拷贝（自己封装）：for in实现
// JSON序列化：缺点==无法拷贝函数或者undefined，会丢失函数和undefined
// let DadProto = {
//   name: '张三',
//   age: 22
// }
// DadProto.prototype.hobby = function() {
//   console.log('喜欢篮球')
// }
// let SonProto = JSON.parse(JSON.stringify(DadProto))
// SonProto.name = '李四'
// DadProto.hobby()
// console.log(SonProto)
// for in 循环自身属性和方法，以及原型和原型链上的属性和方法
function deepCopy(obj) {
  let newObj = Array.isArray(obj) ? [] : {}
  for(let key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (typeof obj[key] === 'object') {
        newObj = deepCopy(obj[key])
      } else {
        newObj[key] = obj[key]
      }
    }
  }
  return newObj
}

let obj = {
  name: '张三',
  age: 20
}
obj.hobby = function() {
  console.log('喜欢篮球')
}
let obj1 = deepCopy(obj)
obj1.age = 22
// console.log(obj.age)
// console.log(obj1)
function Dad(name, age) {
  this.name = name
  this.age = age
  this.money = '100000'
}
function Son(name,age) {
  Dad.call(this, name, age)
  this.sex = '男'
}
Dad.prototype.hobby=function() {
  console.log('喜欢象棋')
}
Son.prototype = deepCopy(Dad.prototype)
let zhangsan = new Son('张三',20)
let zhangyi = new Dad('张一', 50)
zhangsan.age = 22
console.log(zhangyi)
</script>
</html>